import { Component, OnInit, OnDestroy, Output, EventEmitter, inject, signal, effect, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { FontAwesomeModule } from '@fortawesome/angular-fontawesome';
import { faSearch, faTimes, faLink, faImage, faStickyNote, faLightbulb, faMicrochip, faListCheck, faNetworkWired, faFilm, faClock, faRss } from '@fortawesome/free-solid-svg-icons';
import { IconCatalogService, IconCatalogEntry, IconCategory } from '../../../../core/services/icon-catalog.service';
import { ThemeService } from '../../../../core/services/theme.service';
import { AddCardModalService } from '../../../../core/services/add-card-modal.service';
import { CardService } from '../../../../core/services/card.service';
import { Subject } from 'rxjs';
import { debounceTime, distinctUntilChanged } from 'rxjs/operators';

@Component({
  selector: 'app-add-card-modal',
  standalone: true,
  imports: [CommonModule, FormsModule, FontAwesomeModule],
  templateUrl: './add-card-modal.component.html',
  styleUrls: ['./add-card-modal.component.scss']
})
export class AddCardModalComponent implements OnInit, OnDestroy {
  private iconCatalog = inject(IconCatalogService);
  private themeService = inject(ThemeService);
  private addCardModal = inject(AddCardModalService);
  private cardService = inject(CardService);

  @Output() cardCreated = new EventEmitter<{
    title: string;
    subtitle?: string;
    url?: string;
    iconSource: 'catalog' | 'custom';
    iconCatalogId?: string;
    iconCustomUrl?: string;
  }>();

  @Output() cancelled = new EventEmitter<void>();

  // Icons
  faSearch = faSearch;
  faTimes = faTimes;
  faLink = faLink;
  faImage = faImage;
  faStickyNote = faStickyNote;
  faLightbulb = faLightbulb;
  faMicrochip = faMicrochip;
  faListCheck = faListCheck;
  faNetworkWired = faNetworkWired;
  faFilm = faFilm;
  faClock = faClock;
  faRss = faRss;

  // Media server icons from catalog
  plexIconUrl = computed(() => {
    const themeVariant = this.themeService.themeVariant();
    return this.iconCatalog.getIconForThemeVariant('plex', themeVariant) || '/app-icons/svg/plex.svg';
  });

  jellyfinIconUrl = computed(() => {
    const themeVariant = this.themeService.themeVariant();
    return this.iconCatalog.getIconForThemeVariant('jellyfin', themeVariant) || '/app-icons/svg/jellyfin.svg';
  });

  // Card type
  cardType = signal<'regular' | 'widget'>('regular');
  widgetType = signal<'note' | 'system-metrics' | 'system-processes' | 'system-network' | 'plex' | 'jellyfin' | 'clock' | 'rss'>('note');

  // Form fields
  title = signal('');
  subtitle = signal('');
  url = signal('');

  // Plex widget fields
  plexServerUrl = signal('');
  plexToken = signal('');

  // Jellyfin widget fields
  jellyfinServerUrl = signal('');
  jellyfinApiKey = signal('');

  // Clock widget fields
  clockFormat = signal<'12h' | '24h'>('24h');
  clockShowSeconds = signal(true);
  clockShowDate = signal(true);
  clockStyle = signal<'digital' | 'analog'>('digital');

  // RSS widget fields
  rssFeedUrl = signal('');
  rssWidgetName = signal('');
  rssItemLimit = signal(10);
  rssShowDescription = signal(true);
  rssShowPublishDate = signal(true);

  // Icon selection
  iconSource = signal<'catalog' | 'custom'>('catalog');
  selectedIconId = signal<string | null>(null);
  customIconUrl = signal('');
  iconSearchQuery = signal('');

  // Icon catalog
  categories = signal<IconCategory[]>([]);
  selectedCategory = signal<string | null>(null);
  filteredIcons = signal<IconCatalogEntry[]>([]);

  // Search debouncing
  private searchSubject = new Subject<string>();

  // Edit mode
  editingCard = this.addCardModal.editingCard;
  isEditMode = computed(() => this.editingCard() !== null);
  modalTitle = computed(() => this.isEditMode() ? 'Edit Card' : 'Add New Card');

  constructor() {
    // Populate form fields when editingCard changes
    effect(() => {
      const card = this.editingCard();
      if (card) {
        this.title.set(card.title);
        this.subtitle.set(card.subtitle || '');

        // Extract URL from meta
        try {
          const meta = typeof card.meta === 'string' ? JSON.parse(card.meta) : card.meta;
          this.url.set(meta?.url || '');
        } catch {
          this.url.set('');
        }

        // Set icon source and selection
        if (card.iconSource === 'catalog' && card.iconCatalogId) {
          this.iconSource.set('catalog');
          this.selectedIconId.set(card.iconCatalogId);
        } else if (card.iconCustomUrl) {
          this.iconSource.set('custom');
          this.customIconUrl.set(card.iconCustomUrl);
          this.selectedIconId.set(null);
        }
      } else {
        // Reset form for create mode
        this.resetForm();
      }
    });
  }

  ngOnInit(): void {
    this.iconCatalog.getCategories().subscribe({
      next: (cats) => {
        this.categories.set(cats);

        // Default to first category
        if (cats.length > 0) {
          this.selectedCategory.set(cats[0].id);
          this.filteredIcons.set(cats[0].icons);
        }
      }
    });

    // Set up debounced search
    this.searchSubject.pipe(
      debounceTime(300), // Wait 300ms after user stops typing
      distinctUntilChanged() // Only emit if value changed
    ).subscribe(query => {
      this.performSearch(query);
    });
  }

  ngOnDestroy(): void {
    this.searchSubject.complete();
  }

  selectCategory(categoryId: string): void {
    this.selectedCategory.set(categoryId);
    const category = this.categories().find(c => c.id === categoryId);
    if (category) {
      this.filteredIcons.set(category.icons);
    }
    this.iconSearchQuery.set('');
  }

  searchIcons(query: string): void {
    this.iconSearchQuery.set(query);
    this.searchSubject.next(query);
  }

  private performSearch(query: string): void {
    if (!query.trim()) {
      // Reset to selected category
      const category = this.categories().find(c => c.id === this.selectedCategory());
      if (category) {
        this.filteredIcons.set(category.icons);
      }
    } else {
      // Search across all icons
      this.iconCatalog.searchIcons(query).subscribe({
        next: (results) => {
          this.filteredIcons.set(results);
        }
      });
    }
  }

  selectIcon(iconId: string): void {
    this.selectedIconId.set(iconId);
    this.iconSource.set('catalog');
  }

  setCustomIcon(): void {
    this.iconSource.set('custom');
    this.selectedIconId.set(null);
  }

  getSelectedIcon(): IconCatalogEntry | undefined {
    const id = this.selectedIconId();
    return id ? this.iconCatalog.getIconById(id) : undefined;
  }

  getIconUrl(icon: IconCatalogEntry): string {
    const themeVariant = this.themeService.themeVariant();
    return this.iconCatalog.getIconForThemeVariant(icon.id, themeVariant) || icon.iconUrl;
  }

  resetForm(): void {
    this.cardType.set('regular');
    this.widgetType.set('note');
    this.title.set('');
    this.subtitle.set('');
    this.url.set('');
    this.iconSource.set('catalog');
    this.selectedIconId.set(null);
    this.customIconUrl.set('');
    this.iconSearchQuery.set('');
  }

  isRegularCard(): boolean {
    return this.cardType() === 'regular';
  }

  isWidgetCard(): boolean {
    return this.cardType() === 'widget';
  }

  handleSubmit(): void {
    // Only require title for regular cards
    if (this.isRegularCard() && !this.title().trim()) {
      alert('Please enter a title');
      return;
    }

    // Validate RSS widget fields
    if (this.isWidgetCard() && this.widgetType() === 'rss') {
      if (!this.rssFeedUrl().trim()) {
        alert('Please enter an RSS feed URL');
        return;
      }
      if (!this.rssWidgetName().trim()) {
        alert('Please enter a widget name');
        return;
      }
    }

    // Validate Plex widget fields
    if (this.isWidgetCard() && this.widgetType() === 'plex') {
      if (!this.plexServerUrl().trim()) {
        alert('Please enter a Plex server URL');
        return;
      }
      if (!this.plexToken().trim()) {
        alert('Please enter a Plex token');
        return;
      }
    }

    // Validate Jellyfin widget fields
    if (this.isWidgetCard() && this.widgetType() === 'jellyfin') {
      if (!this.jellyfinServerUrl().trim()) {
        alert('Please enter a Jellyfin server URL');
        return;
      }
      if (!this.jellyfinApiKey().trim()) {
        alert('Please enter a Jellyfin API key');
        return;
      }
    }

    const cardData: any = {};

    // Handle widget cards
    if (this.isWidgetCard()) {
      // Set default title and layout based on widget type
      switch (this.widgetType()) {
        case 'note':
          cardData.title = 'Note';
          cardData.layoutW = 2;
          cardData.layoutH = 2;
          cardData.layoutMinW = 2;
          cardData.layoutMinH = 2;
          break;
        case 'system-metrics':
          cardData.title = 'System Metrics';
          cardData.layoutW = 3;
          cardData.layoutH = 5;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 5;
          cardData.layoutMaxW = 3;
          cardData.layoutMaxH = 5;
          break;
        case 'system-processes':
          cardData.title = 'System Processes';
          cardData.layoutW = 3;
          cardData.layoutH = 6;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 6;
          cardData.layoutMaxW = 3;
          cardData.layoutMaxH = 6;
          break;
        case 'system-network':
          cardData.title = 'Network Stats';
          cardData.layoutW = 3;
          cardData.layoutH = 4;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 4;
          cardData.layoutMaxW = 3;
          cardData.layoutMaxH = 4;
          break;
        case 'plex':
          cardData.title = 'Plex Media Server';
          cardData.layoutW = 3;
          cardData.layoutH = 7;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 7;
          break;
        case 'jellyfin':
          cardData.title = 'Jellyfin Media Server';
          cardData.layoutW = 3;
          cardData.layoutH = 7;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 7;
          break;
        case 'clock':
          cardData.title = 'Clock';
          if (this.clockStyle() === 'analog') {
            cardData.layoutW = 2;
            cardData.layoutH = 3;
            cardData.layoutMinW = 2;
            cardData.layoutMinH = 3;
          } else {
            cardData.layoutW = 3;
            cardData.layoutH = 2;
            cardData.layoutMinW = 3;
            cardData.layoutMinH = 2;
          }
          break;
        case 'rss':
          cardData.title = this.rssWidgetName() || 'RSS Feed';
          cardData.layoutW = 3;
          cardData.layoutH = 6;
          cardData.layoutMinW = 3;
          cardData.layoutMinH = 4;
          break;
      }

      cardData.iconSource = 'catalog';

      // Build widget config based on type
      let widgetConfig: any = {};
      if (this.widgetType() === 'note') {
        widgetConfig.content = '<p>Start writing your notes here...</p>';
      } else if (this.widgetType() === 'plex') {
        widgetConfig.serverUrl = this.plexServerUrl();
        widgetConfig.token = this.plexToken();
        widgetConfig.showNowPlaying = true;
        widgetConfig.showRecent = true;
        widgetConfig.recentLimit = 10;
        widgetConfig.refreshInterval = 10;
      } else if (this.widgetType() === 'jellyfin') {
        widgetConfig.serverUrl = this.jellyfinServerUrl();
        widgetConfig.apiKey = this.jellyfinApiKey();
        widgetConfig.showNowPlaying = true;
        widgetConfig.showRecent = true;
        widgetConfig.recentLimit = 10;
        widgetConfig.refreshInterval = 10;
      } else if (this.widgetType() === 'clock') {
        widgetConfig.format = this.clockFormat();
        widgetConfig.showSeconds = this.clockShowSeconds();
        widgetConfig.showDate = this.clockShowDate();
        widgetConfig.style = this.clockStyle();
      } else if (this.widgetType() === 'rss') {
        widgetConfig.feedUrl = this.rssFeedUrl();
        widgetConfig.widgetName = this.rssWidgetName() || 'RSS Feed';
        widgetConfig.itemLimit = this.rssItemLimit();
        widgetConfig.refreshInterval = 300; // 5 minutes default
        widgetConfig.showDescription = this.rssShowDescription();
        widgetConfig.showPublishDate = this.rssShowPublishDate();
      }

      cardData.widgets = [{
        type: this.widgetType(),
        config: widgetConfig
      }];

      // Widget cards don't need icons, URLs, or titles
    } else {
      // Regular card - add title and other fields
      cardData.title = this.title();
      cardData.subtitle = this.subtitle() || undefined;
      cardData.iconSource = this.iconSource();

      // Handle meta field (URL)
      if (this.url()) {
        cardData.meta = { url: this.url() };
      }

      if (this.iconSource() === 'catalog' && this.selectedIconId()) {
        cardData.iconCatalogId = this.selectedIconId();
        // Use theme-aware icon variant
        const themeVariant = this.themeService.themeVariant();
        const iconUrl = this.iconCatalog.getIconForThemeVariant(this.selectedIconId()!, themeVariant);
        if (iconUrl) {
          cardData.iconCustomUrl = iconUrl;
        }
      } else if (this.iconSource() === 'custom' && this.customIconUrl()) {
        cardData.iconCustomUrl = this.customIconUrl();
      }
    }

    if (this.isEditMode()) {
      // Update existing card
      const card = this.editingCard();
      if (card) {
        this.cardService.updateCard(card.id, cardData).subscribe({
          next: () => {
            // Emit event BEFORE closing so editingCard is still set
            this.cardCreated.emit(cardData);
            this.addCardModal.close();
          },
          error: (err) => {
            console.error('Failed to update card:', err);
            alert('Failed to update card. Please try again.');
          }
        });
      }
    } else {
      // Create new card - emit data for parent to handle
      this.cardCreated.emit(cardData);
    }
  }

  handleCancel(): void {
    this.cancelled.emit();
  }
}
